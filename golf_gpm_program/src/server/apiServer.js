// src/server/apiServer.js
const express = require('express');
const http = require('http');
const fs = require('fs');
const path = require('path');
const { findReservationTab } = require('../services/puppeteer');
let app = null;
try {
    app = require('electron').app;
} catch (e) {
    app = null;
}

let serverInstance = null;


function getReservationLogPath() {
    const file = 'reservation-log.json';

    // Í∞úÎ∞ú ÌôòÍ≤Ω
    const devPath = path.join(__dirname, '..', '..', 'logs', file);
    if (!app || !app.isPackaged) return devPath;

    // Î∞∞Ìè¨ ÌôòÍ≤Ω ÌõÑÎ≥¥ Í≤ΩÎ°úÎì§
    const resourcesPath = process.resourcesPath;
    const appRoot = path.dirname(resourcesPath);

    const candidates = [
        path.join(resourcesPath, 'logs', file),
        path.join(appRoot,       'logs', file),
        path.join(resourcesPath, 'resources', 'logs', file),
        path.join(resourcesPath, 'app.asar.unpacked', 'logs', file),
    ];

    for (const p of candidates) {
        if (fs.existsSync(p)) return p;
    }

    // ÏïÑÎ¨¥Í≤ÉÎèÑ ÏóÜÎã§Î©¥ fallback Í≤ΩÎ°ú ÏÉùÏÑ±
    const fallback = candidates[0];
    const dir = path.dirname(fallback);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    return fallback;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Ïú†Ìã∏: ÌòÑÏû¨ ÏãúÍ∞Ñ Ìè¨Îß∑
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getNow() {
    const now = new Date();
    const pad = (n) => n.toString().padStart(2, '0');
    return `${now.getFullYear()}.${pad(now.getMonth() + 1)}.${pad(now.getDate())} ${pad(now.getHours())}.${pad(now.getMinutes())}.${pad(now.getSeconds())}`;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Ïú†Ìã∏: ÏòàÏïΩ ÎÇ†Ïßú Î¨∏ÏûêÏó¥ ‚Üí ÎÖÑ/ÏõîÎ°ú ÌååÏã±
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function parseBookingDate(bookingDate) {
    const year = parseInt(bookingDate.slice(0, 4), 10);
    const month = parseInt(bookingDate.slice(4, 6), 10);
    return { targetYear: year, targetMonth: month };
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Î°úÍ∑∏ Í∏∞Î°ù (JSON ÌååÏùºÏóê append)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function writeLog(entry) {
    const logPath = getReservationLogPath();
    nodeLog('üìù Î°úÍ∑∏ Í∏∞Î°ù ÏôÑÎ£å:', entry, '‚Üí Ï†ÄÏû• ÏúÑÏπò:', logPath);
    const dir = path.dirname(logPath);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

    let data = [];
    if (fs.existsSync(logPath)) {
        try {
            const raw = fs.readFileSync(logPath, 'utf-8');
            data = raw.trim() ? JSON.parse(raw) : [];
        } catch (e) {
            nodeError('‚ùå JSON Î°úÍ∑∏ ÌååÏã± Ïã§Ìå®:', e.message);
            data = [];
        }
    }

    data.push(entry);
    try {
        fs.writeFileSync(logPath, JSON.stringify(data, null, 2), 'utf-8');
        nodeLog('üìù Î°úÍ∑∏ Í∏∞Î°ù ÏôÑÎ£å: ' + JSON.stringify(entry, null, 2));
    } catch (e) {
        nodeError('‚ùå JSON Î°úÍ∑∏ Ïì∞Í∏∞ Ïã§Ìå®:', e.message);
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÏòàÏïΩ Ï≤òÎ¶¨ Ïû¨ÏãúÎèÑ (1Í±¥)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function handleReservationRetry(logEntry) {
    const { bookingDate, type } = logEntry;
    nodeLog(`üîÅ ÏòàÏïΩ Ïû¨ÏãúÎèÑ ÏãúÏûë (${bookingDate}, type=${type})`);

    try {
        const page = await findReservationTab();
        nodeLog('‚úÖ ÏòàÏïΩ ÌÉ≠ ÌéòÏù¥ÏßÄ ÌôïÎ≥¥ ÏôÑÎ£å');

        await page.reload({ waitUntil: 'networkidle2', timeout: 60000 });
        nodeLog('üîÑ ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å');

        await new Promise(resolve => setTimeout(resolve, 3000));

        const { targetYear, targetMonth } = parseBookingDate(bookingDate);
        const calendarExists = await page.$('.vfc-main-container');

        if (!calendarExists) {
            nodeLog('üìÖ Îã¨Î†• Îã´Ìûò ÏÉÅÌÉú ‚Üí Ïó¥Í∏∞ ÏãúÎèÑ');
            await page.waitForSelector('.btn_clander', { timeout: 1500 });
            await page.click('.btn_clander');
            nodeLog('üñ±Ô∏è Îã¨Î†• Ïó¥Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠ ÏôÑÎ£å');
        }

        await page.waitForSelector('.vfc-top-date.vfc-center', { timeout: 5000 });

        const { currentYear, currentMonth } = await page.evaluate(() => {
            const elements = document.querySelectorAll('.vfc-top-date.vfc-center a');
            return {
                currentMonth: parseInt(elements[0]?.textContent.trim().replace('Ïõî', '')),
                currentYear: parseInt(elements[1]?.textContent.trim())
            };
        });

        nodeLog(`üìÜ ÌòÑÏû¨ Îã¨Î†• ÏúÑÏπò: ${currentYear}ÎÖÑ ${currentMonth}Ïõî / Î™©Ìëú: ${targetYear}ÎÖÑ ${targetMonth}Ïõî`);

        const diffMonth = (targetYear - currentYear) * 12 + (targetMonth - currentMonth);
        const direction = diffMonth > 0 ? 'right' : 'left';
        const clicks = Math.abs(diffMonth);
        const selector = direction === 'right' ? '.vfc-arrow-right' : '.vfc-arrow-left';

        for (let i = 0; i < clicks; i++) {
            await page.waitForSelector(selector, { timeout: 3000 });
            await page.click(selector);
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        nodeLog(`‚ÜîÔ∏è Îã¨Î†• ${direction} Î∞©Ìñ•ÏúºÎ°ú ${clicks}Ìöå Ïù¥Îèô ÏôÑÎ£å`);

        const targetDay = parseInt(bookingDate.slice(6, 8));
        const clicked = await page.evaluate((day) => {
            const weeks = document.querySelectorAll('.vfc-week');
            for (const week of weeks) {
                const dayDivs = week.querySelectorAll('.vfc-day');
                for (const div of dayDivs) {
                    const span = div.querySelector('.vfc-span-day');
                    if (span && !span.classList.contains('vfc-hide') && parseInt(span.textContent.trim()) === day) {
                        span.click();
                        return true;
                    }
                }
            }
            return false;
        }, targetDay);

        if (!clicked) {
            nodeLog(`‚ùå ${targetDay}Ïùº ÌÅ¥Î¶≠ Ïã§Ìå®`);
            logEntry.result = 'fail';
            logEntry.error = 'retry target date not found';
        } else {
            nodeLog(`‚úÖ ${targetDay}Ïùº ÌÅ¥Î¶≠ ÏôÑÎ£å`);
            logEntry.result = 'success';
            logEntry.error = null;
        }

    } catch (err) {
        nodeError('‚ùå ÏòàÏïΩ Ï≤òÎ¶¨ Ï§ë ÏòàÏô∏:', err.message);
        logEntry.result = 'fail';
        logEntry.error = err.message;
    } finally {
        const logPath = getReservationLogPath();
        try {
            const raw = fs.readFileSync(logPath, 'utf-8');
            const data = raw.trim() ? JSON.parse(raw) : [];
            const idx = data.findIndex(e => e.bookingDate === logEntry.bookingDate && e.requestDate === logEntry.requestDate);
            if (idx !== -1) {
                data[idx] = logEntry;
                fs.writeFileSync(logPath, JSON.stringify(data, null, 2), 'utf-8');
                nodeLog('üìå Î°úÍ∑∏ Í≤∞Í≥º Í∞±Ïã† ÏôÑÎ£å:', logEntry.result);
            }
        } catch (e) {
            nodeError('‚ùå [Ïû¨ÏãúÎèÑ] Î°úÍ∑∏ Í∞±Ïã† Ïã§Ìå®:', e.message);
        }
    }
}


function retryFailedReservations() {
    const logPath = getReservationLogPath();
    if (!fs.existsSync(logPath)) return;

    let data = [];
    try {
        data = JSON.parse(fs.readFileSync(logPath, 'utf-8'));
    } catch (e) {
        nodeError('‚ùå Ïû¨ÏãúÎèÑ Î°úÍ∑∏ ÌååÏã± Ïã§Ìå®:', e.message);
        return;
    }

    const failEntries = data.filter(entry => entry.result !== 'success');
    if (failEntries.length === 0) {
        nodeLog('‚úÖ Ïã§Ìå® Î°úÍ∑∏ ÏóÜÏùå ‚Üí Ïû¨ÏãúÎèÑ ÏÉùÎûµ');
        return;
    }

    nodeLog(`üîÅ Ïã§Ìå®Ìïú ÏòàÏïΩ ${failEntries.length}Í±¥ Ïû¨ÏãúÎèÑ ÏãúÏûë`);

    failEntries.forEach((entry, idx) => {
        setTimeout(() => {
            handleReservationRetry(entry);
        }, 5000 * idx);
    });
}

async function startApiServer(port = 32123) {
    await stopApiServer(); // ‚úÖ ÏïàÏ†ÑÌïòÍ≤å Í∏∞Îã§Î¶∞ ÌõÑ

    const app = express();

    app.get('/reseration', async (req, res) => {
        const { bookingDate, type } = req.query;

        if (!bookingDate) return res.status(400).json({ message: 'bookingDate required' });

        const delayMs = type === 'm' ? 1000 * 60 * 5 : 1000 * 60;
        const logEntry = {
            bookingDate,
            type,
            requestDate: getNow(),
            result: 'pending',
            error: null
        };

        nodeLog(`üì• ÏòàÏïΩ ÏöîÏ≤≠ ÏàòÏã† (${bookingDate}, type=${type}) ‚Üí ${delayMs / 60000}Î∂Ñ ÌõÑ Ïã§Ìñâ ÏòàÏ†ï`);
        res.sendStatus(200);

        setTimeout(() => handleReservationRetry(logEntry), delayMs);
        writeLog(logEntry);
    });

    serverInstance = http.createServer(app);
    serverInstance.listen(port, () => {
        nodeLog(`üåê API ÏÑúÎ≤Ñ Ïã§Ìñâ Ï§ë: http://localhost:${port}/reseration`);
    });

    setInterval(retryFailedReservations, 1000 * 60 * 10);
}

function stopApiServer() {
    return new Promise((resolve) => {
        if (serverInstance) {
            serverInstance.close(() => {
                nodeLog('üõë API ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏôÑÎ£å');
                serverInstance = null;
                resolve();
            });
        } else {
            resolve();
        }
    });
}

module.exports = {
    startApiServer,
    stopApiServer
};
